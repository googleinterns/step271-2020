// TESTS FOR GoogleCalendarTimesDAO.findTimes
describe('GoogleCalendarTimesDAO.findTimes', function() {
  const GUEST_LIST = ['anna@test.com', 'anna@example.com'];
  const DURATION_HOURS = '1'; // The values would be stored as Strings in sessionStorage
  const DURATION_MINS = '30';
  const PERIOD_START = '2021-02-12T15:30'
  const PERIOD_END = '2021-02-13T15:30';
  const TIME_DATA = ['2021-02-12T16:00:00.000Z', '2021-02-12T20:00:00.000Z'];
  const QUERY_STRING = '?guest-list=' + encodeURIComponent(GUEST_LIST) + 
      '&duration-hours=' + DURATION_HOURS +
      '&duration-mins=' + DURATION_MINS +  
      '&period-start=' + encodeURIComponent(PERIOD_START) + 
      '&period-end=' + encodeURIComponent(PERIOD_END);

  beforeAll(function() {
    spyOn(MeetingEventDAO, 'getGuestList').and.returnValue(GUEST_LIST);
    spyOn(MeetingEventDAO, 'getDurationHours').and.returnValue(DURATION_HOURS);
    spyOn(MeetingEventDAO, 'getDurationMins').and.returnValue(DURATION_MINS);
  });

  beforeEach(function() {
    let responseInit = null;
    spyOn(window, 'fetch').and.callFake(async function() {
        return new Response(JSON.stringify(TIME_DATA), responseInit);
    });
  });

  it('returns the list of the possible meeting times generated by the servlet \
     on success', async function() {
    let times = await GoogleCalendarTimesDAO.findTimes(PERIOD_START, PERIOD_END);
    expect(times.length).toEqual(TIME_DATA.length);
    expect(times).toEqual(TIME_DATA);
    expect(window.fetch).toHaveBeenCalledWith(GoogleCalendarTimesDAO.endpoint + QUERY_STRING);
  });

  it('throws an exception if the periodStart param is not provided', async function() {
    let periodStart = null;
    await verifyErrorThrown(periodStart, PERIOD_END, INSUFFICIENT_REQUEST_PARAM);
  });

  it('throws an exception if the periodEnd param is not provided', async function() {
    let periodEnd = null;
    await verifyErrorThrown(PERIOD_START, periodEnd, INSUFFICIENT_REQUEST_PARAM);
  });

  it('throws an exception if the periodStart param is not a string', async function() {
    let periodStart = 123;
    await verifyErrorThrown(periodStart, PERIOD_END, INVALID_PARAM_TYPE);
  });

  it('throws an exception if the periodEnd param is not a string', async function() {
    let periodEnd = {someField: 'someValue'};
    await verifyErrorThrown(PERIOD_START, periodEnd, INVALID_PARAM_TYPE);
  });

  it('throws an exception if the periodStart param is not in the correct format', async function() {
    let periodStart = '12th February 2021 4:00PM';
    await verifyErrorThrown(periodStart, PERIOD_END, INVALID_PARAM_VALUE);
  });

  it('throws an exception if the periodEnd param is not in the correct format', async function() {
    let periodEnd = '12th February 2021 4:00PM';
    await verifyErrorThrown(PERIOD_START, periodEnd, INVALID_PARAM_VALUE);
  });
});

/**
 * Verify that an error is thrown, and fetch is not called provided 
 * the arguments to GoogleCalendarTimesDAO.
 * @param {String} periodStart The periodStart argument to
 * be passed to GoogleCalendarTimesDAO.findTimes()
 * @param {String} periodEnd The periodEnd argument to be 
 * passed to GoogleCalendarTimesDAO.findTimes().
 * @param {String} expectedMessage the expected error message 
 * of the Error thrown 
 */
async function verifyErrorThrown(periodStart, periodEnd, expectedMessage) {
  let errorMessage;
  try {
    await GoogleCalendarTimesDAO.findTimes(periodStart, periodEnd);
  } catch (error) {
    errorMessage = error.message;
  }
  expect(errorMessage).toEqual(expectedMessage);
  expect(window.fetch).not.toHaveBeenCalled();
}
