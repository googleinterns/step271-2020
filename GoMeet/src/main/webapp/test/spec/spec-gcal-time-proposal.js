// TESTS FOR rectifyTimeBoundaries
describe('rectifyTimeBoundaries', function() {
  const TIME_PAST = '2021-02-11T12:00';
  const FAKE_NOW = new Date(2021, 1, 12, 12, 0, 0, 0); // Time now: 2021-02-12T12:00
  const TIME_START = '2021-02-13T14:00' ; 
  const TIME_END = '2021-02-14T15:00';
  
  beforeEach(function() {
    // mock the Date object
    jasmine.clock().install()
    jasmine.clock().mockDate(FAKE_NOW);
  });

  it('returns true if both start and end are in the future \
      and end is later than start', function() {
    expect(rectifyTimeBoundaries(TIME_START, TIME_END)).toBe(true);
  });

  it('returns false if start is in the past', function() {
    expect(rectifyTimeBoundaries(TIME_PAST, TIME_END)).toBe(false);
  });

  it('returns false if end is earlier than start', function() {
    // This case also covers the case where end time is in the past.
    expect(rectifyTimeBoundaries(TIME_START, TIME_PAST)).toBe(false);
  });

  afterEach(function() {
    jasmine.clock().uninstall();
  }); 
});

// TESTS FOR generateTimes
describe('generateTimes', function() {
  let rectifyTimeBoundariesSpy;
  let startInput;
  let endInput;

  beforeEach(function() {
    rectifyTimeBoundariesSpy = spyOn(window, 'rectifyTimeBoundaries');
    spyOn(GoogleCalendarTimesDAO, 'findTimes');
    spyOn(window, 'alert');
    startInput = document.getElementById('period-start');
    endInput = document.getElementById('period-end');
  });

  it('calls GooglerCalendarTimesDAO.findTimes when period-start \
      and period-end are non-empty and valid', function() {
    // Fill the fields up with some values so that they are not empty
    startInput.value = '2021-02-12T14:00';
    endInput.value = '2021-02-12T20:00';
    rectifyTimeBoundariesSpy.and.returnValue(true);

    generateTimes();

    expect(GoogleCalendarTimesDAO.findTimes).toHaveBeenCalled();
    expect(window.alert).not.toHaveBeenCalled();
  });

  it('resets the period-start and period-end input fields and alerts \
      the user if the input values are invalid', function() {
    // Fill the fields up with some values so that they are not empty.
    startInput.value = '2021-02-12T14:00';
    endInput.value = '2021-02-12T20:00';
    // However, the start and end times are invalid.
    rectifyTimeBoundariesSpy.and.returnValue(false);
    generateTimes();
    checkStartEndReset();
  });

  it('resets the period-start and period-end input fields and alerts \
      the user if the period-start field is empty', function() {
    // The start field is empty.
    endInput.value = '2021-02-12T20:00';
    rectifyTimeBoundariesSpy.and.returnValue(false);
    generateTimes();
    checkStartEndReset();
  });

  it('resets the period-start and period-end input fields and alerts \
      the user if the period-end field is empty', function() {
    startInput.value = '2021-02-12T14:00';
    // The end field is empty.
    rectifyTimeBoundariesSpy.and.returnValue(false);
    generateTimes();
    checkStartEndReset();
  });

  afterEach(function() {
    // Reset the input fields
    startInput.value = '';
    endInput.value = '';
  })
})

/**
 * Checks that period-start and period-end fields were cleared,
 * and that window.alert has been called to alert the user of the
 * error, and that GoogleCalendarTimesDAO.findTimes was not called.
 */
function checkStartEndReset() {
  let startInput = document.getElementById('period-start');
  let endInput = document.getElementById('period-end');
  expect(startInput.value).toEqual('');
  expect(endInput.value).toEqual('');
  expect(GoogleCalendarTimesDAO.findTimes).not.toHaveBeenCalled();
  expect(window.alert).toHaveBeenCalledWith(INVALID_TIME_PERIOD);
}

// TESTS FOR displayAutoGeneratedTimes
describe('displayAutoGeneratedTimes', function() {
  const TIME_DATA = [
    '2021-02-13T09:43:45.321Z', 
    '2021-02-14T10:35:30.761Z', 
    '2021-02-13T13:00:45.543Z'
  ];
  const TIME_DATA_DISPLAYED = [
    '2021-02-13T09:43', 
    '2021-02-14T10:35', 
    '2021-02-13T13:00'
  ];
  const ERROR_RESPONSE = {
    status: 404,
    message: 'This will be an error message',
  };
  let generateTimesDiv;
  
  beforeEach(function() {
    generateTimesDiv = document.getElementById('generated-times');
  })

  it('displays the error message and a button to redirect to the manual \
      time proposal page if serverResponse is not OK, and returns null', function() {
    let displayedTimes = displayAutoGeneratedTimes(ERROR_RESPONSE);
    
    expect(displayedTimes).toBe(null);
    
    // Expect there to be two child elements appended to the div
    expect(generateTimesDiv.childElementCount).toEqual(2);
    // NOTE: Not verifying error message contents, since this is free to 
    // change without affecting program logic.

    // Check that the button has the correct redirect.
    let button = generateTimesDiv.children.item(1);
    expect(button.onclick.toString()).toEqual('function(){redirectTo(\'create-meeting-step2-manual.html\')}');

  });

  it('displays all the times retrieved from the server in individual <p> \
      elements if the serverResponse is OK, and returns the list of displayed times', function() {
    let displayedTimes = displayAutoGeneratedTimes(TIME_DATA);
    expect(displayedTimes.length).toEqual(TIME_DATA_DISPLAYED.length);
    expect(displayedTimes).toEqual(TIME_DATA_DISPLAYED);
    
    // Expect there to be as many children appended as there are times
    expect(generateTimesDiv.childElementCount).toEqual(TIME_DATA.length);
    
    // Check that each child has the relevant contents
    for (let i = 0; i < TIME_DATA_DISPLAYED.length; i++) {
      expect(generateTimesDiv.children.item(i).innerText).toEqual(TIME_DATA_DISPLAYED[i]);
    }
  });

  afterEach(function() {
    // Reset the display div
    generateTimesDiv.innerHTML = '';
  })
});

// TESTS FOR setupNextButton
describe('setupNextButton', function() {
  const TIME_DATA = [
    '2021-02-13T09:43:45.321Z', 
    '2021-02-14T10:35:30.761Z', 
    '2021-02-13T13:00:45.543Z'
  ];

  beforeEach(function() {
    // Disable the button, and remove the onclick property
    let nextButton = document.getElementById('next-button');
    nextButton.disabled = true;
    nextButton.onclick = null;
  });

  it('enables the button with id \'next-button\' and sets the onclick property', function() {
    setupNextButton(TIME_DATA);
    let nextButton = document.getElementById('next-button');
    expect(nextButton.disabled).toBe(false);
    expect(nextButton.onclick.toString()).toBe(
        'function() {saveAutoGeneratedTimes(times);redirectTo(\'create-meeting-step3.html\');}'
    );
  });
});

// TESTS FOR saveAutoGeneratedTimes
describe('saveAutoGeneratedTimes', function() {
  const TIME_DATA = [
    '2021-02-13T09:43:45.321Z', 
    '2021-02-14T10:35:30.761Z', 
    '2021-02-13T13:00:45.543Z'
  ];
  let fakeSessionStorage = {};

  beforeEach(function() {
    spyOn(window, 'redirectTo');
    spyOn(sessionStorage, 'setItem').and.callFake(function(key, item) {
      fakeSessionStorage[key] = item;
    });
  });

  it('saves the times to sessionStorage', function() {
    saveAutoGeneratedTimes(TIME_DATA);
    // Verify that everything has been stored in sessionStorage
    expect(Object.keys(fakeSessionStorage).length).toEqual(TIME_DATA.length);
    for (let i = 0; i < TIME_DATA.length; i++) {
      let expectedKey = 'meeting-time-' + i;
      expect(fakeSessionStorage[expectedKey]).toEqual(TIME_DATA[i]);
    }
  });

  afterEach(function() {
    // Reset fakeSssionStorage
    fakeSessionStorage = {};
  });
});
